'use strict';

const _ = require('lodash');
const prepare = require('prepare-response');
const ms = require('ms');

function noop() {}

module.exports = class AssetMiddleware {
	constructor(filePath, options) {
		this.filePath = filePath;
		this.options = this.normalizeOptions(options);
	}

	static getDefaultOptions() {
		return _.defaults({}, {
			'production': {
				cache: true,
				minify: true
			},
			'staging': {
				cache: true,
				minify: true
			},
			'development': {
				cache: 'dynamic',
				gzip: false,
				debug: true
			}
		}[process.env.NODE_ENV || 'development'] || {}, {
			cache: false,
			minify: false,
			gzip: true,
			debug: false
		});
	}

	normalizeOptions(_options) {
		const defaultOptions = AssetMiddleware.getDefaultOptions();
		const options = _.defaults({}, _options || {}, defaultOptions);

		if (options.cache === 'dynamic') {
			// leave unchanged
		} else if (typeof options.cache === 'string' && ms(options.cache)) {
			options.cache = 'public, max-age=' + Math.floor(ms(options.cache)/1000);
		} else if (options.cache === true) {
			options.cache = 'public, max-age=60';
		} else if (typeof options.cache === 'number') {
			options.cache = 'public, max-age=' + Math.floor(options.cache/1000);
		} else if (typeof options.cache === 'object') {
			options.cache = (options.cache.private ? 'private' : 'public') + ', max-age='
				+ Math.floor(ms(options.cache.maxAge.toString())/1000);
		}

		return options;
	}

	getResponse() {
		var headers = {
			'content-type': this.contentType
		};

		if (this.options.cache && this.options.cache !== 'dynamic') {
			headers['cache-control'] = this.options.cache;
		}

		var response = this.getSource().then((src) => {
			return prepare(src, headers, {gzip: this.options.gzip});
		}).then((response) => {
			return syncResponse = response;
		});

		var syncResponse;

		return {
			send(req, res, next) {
				if (syncResponse) {
					return syncResponse.send(req, res);
				}

				return response.then((response) => {
					response.send(req, res);
				}, next);
			},
			dispose: noop
		};
	}

	buildResponse() {
		if (!this.options.cache) {
			return {
				send(req, res, next) {
					this.getResponse().send(req, res, next);
				},
				dispose: noop
			};
		} else if (this.options.cache !== 'dynamic') {
			return this.getResponse();
		}

		var response, resolve;
		var updatingTimeout;
		const watcherDisposer = this.watch(() => {
			if (resolve) {
				clearTimeout(updatingTimeout);
			} else {
				response = new Promise((_resolve) => {
					resolve = _resolve;
				});
			}

			updatingTimeout = setTimeout(() => {
				resolve(this.getResponse());
				resolve = undefined;
			}, 600);
		});

		response = Promise.resolve(this.getResponse());

		return {
			send(req, res, next) {
				response.then((response) => {
					response.send(req, res, next);
				}, next);
			},
			dispose() {
				watcherDisposer();
			}
		};
	}

	watch(onUpdateFn) {
		const chokidar = require('chokidar');

		const watcher = chokidar.watch(this.options.watch, {
			ignored: /[\/\\]\./,
			persistent: true
		}).on('all', onUpdateFn);

		return () => {
			watcher.close();
		};
	}
};
